#ifndef _BOB_CONTROL_CURVE_COMMAND_H_
#define _BOB_CONTROL_CURVE_COMMAND_H_

#include <bob_control/commands/isimple_command.h>
#include <bob_control/conditions/istop_condition.h>
#include <bob_control/conditions/null_condition.h>
#include <bob_control/runnable.h>
#include <bob_control/curve_planner.h>

#include <bob_toolbox/circular_direction.h>
#include <bob_toolbox/line.h>

namespace bob
{
	//! \brief Defines an ISimpleCommand for curving.
	//!
	//! CurveCommand including the curve radius, the curvint direction, 
	//! the linear velocity to curve, the line to curve to and an optional
	//! additional condition.
	//!
	//! By executing the runnable generated by CurveCommand, the robot will
	//! curve the given radius with given direction and velocity to the given
	//! line, and stop on obstacle, goal and given additional condition. 
	struct CurveCommand : public ISimpleCommand
	{
		//! \brief Constructor
		//! \param radius Desired curve radius
		//! \param direction Desired curving direction
		//! \param linearVelocity Curving linear velocity, the angular velocity 
		//! can be calculated by linearVelocity/radius
		//! \param toCurveTo The line to curve to 
		//! \param additionalCondition Optional additional stop condition
		CurveCommand(float radius, CircularDirection direction, float linearVelocity, Line toCurveTo, IStopCondition::shared_ptr additionalCondition = NullCon) : 
			radius(radius),
			linearVelocity(linearVelocity),
			direction(direction),
			toCurveTo(toCurveTo),
			additionalCondition(additionalCondition)
		{}
		
		//! \brief Constructor
		//! \param curveSpecifics parameters of the curve including radius, direction,
		//! linear velocity and line to curve to
		//! \param additionalCondition Optional additional stop condition
		CurveCommand(CurvePlanner::CurveSpecifics curveSpecifics, IStopCondition::shared_ptr additionalCondition = NullCon) : 
			radius(curveSpecifics.radius),
			linearVelocity(curveSpecifics.velocity),
			direction(curveSpecifics.direction),
			toCurveTo(curveSpecifics.toCurveTo),
			additionalCondition(additionalCondition)
		{}

		virtual IController::shared_ptr generateController(const ISensorHandle& sensorHandle) const;

		virtual OredCondition::shared_ptr generateCondition(const ISensorHandle& sensorHandle, IStopCondition*& obstacleCondition, IStopCondition*& goalCondition) const;

		float radius;
		float linearVelocity;		
		CircularDirection direction;
		Line toCurveTo;

		IStopCondition::shared_ptr additionalCondition;

	};

}

#endif
